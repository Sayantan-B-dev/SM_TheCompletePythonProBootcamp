## STEP 2 — DATA & STATE MANAGEMENT SYSTEM (`data_manager.py`)

> Scope of this step
> Only **data ingestion**, **state validation**, **lookup structures**, **progress tracking**, and **CSV export**
> No UI, no turtle, no game loop decisions

---

## Purpose of `DataManager`

`DataManager` is the **data authority** of the application.

It answers questions like:

* What states exist?
* Is a guess valid?
* Where should a state be written?
* Which states are missing?
* How do we persist learning progress?

It is intentionally **UI-agnostic**.

---

## Class Responsibility Boundary

| Concern              | Handled Here? |
| -------------------- | ------------- |
| CSV parsing          | Yes           |
| State validation     | Yes           |
| Coordinate lookup    | Yes           |
| Guess tracking       | Yes           |
| Missing-state export | Yes           |
| Rendering / input    | No            |

---

## Class Initialization — `__init__`

```python
def __init__(self, csv_file):
```

### Responsibility

* Load dataset
* Normalize essential structures
* Prepare fast lookups

This method is executed **once**, at program start.

---

### Reading the CSV (Pandas Ingestion)

```python
self.data = pd.read_csv(csv_file)
```

What pandas does internally:

* Reads raw CSV text
* Builds a `DataFrame`
* Infers column types
* Assigns column labels

Expected columns in `50_states.csv`:

| Column  | Meaning             |
| ------- | ------------------- |
| `state` | State name          |
| `x`     | X-coordinate on map |
| `y`     | Y-coordinate on map |

---

## Extracting All Valid States

```python
self.all_states = self.data.state.to_list()
```

### Why Convert to List?

* Membership checks (`in`) are fast enough
* Order preserved
* Simple mental model

This becomes the **source of truth** for valid guesses.

---

## Tracking Player Progress

```python
self.guessed_states = []
```

Design intent:

* Stores only **correct guesses**
* Prevents duplicates
* Order does not matter

This list represents **game memory**.

---

## Building the Lookup Dictionary (`state_positions`)

```python
self.state_positions = {}
for _, row in self.data.iterrows():
    self.state_positions[row.state] = (row.x, row.y)
```

### Why This Exists

Without this:

* You would repeatedly search the DataFrame
* That would be slow and verbose

With this:

* O(1) coordinate lookup
* Clean separation of concerns

---

### Resulting Structure

```python
{
  "Alabama": (139, -77),
  "Alaska": (-280, -220),
  ...
}
```

This is a **precomputed index**, not raw data.

---

## `is_valid_state` — Input Validation

```python
def is_valid_state(self, state_name):
    return state_name in self.all_states
```

### Responsibility

* Determines legitimacy of a guess
* Does not mutate state
* Pure boolean function

Why this is important:

* Keeps validation logic centralized
* Prevents duplicated checks in `main.py`

---

## `add_guess` — Progress Mutation

```python
def add_guess(self, state_name):
    if state_name not in self.guessed_states:
        self.guessed_states.append(state_name)
```

### Design Notes

| Concern           | Handling   |
| ----------------- | ---------- |
| Duplicate guesses | Prevented  |
| Order             | Preserved  |
| Side effects      | Controlled |

This method is the **only place** where guesses are added.

---

## `get_position` — Coordinate Access

```python
def get_position(self, state_name):
    return self.state_positions[state_name]
```

### Why No Validation Here?

* Assumes caller already validated
* Keeps method fast and simple
* Enforces responsibility boundaries

If validation fails, error visibility is intentional.

---

## `get_missing_states` — Core Learning Feature

```python
def get_missing_states(self):
    missing = []
    for state in self.all_states:
        if state not in self.guessed_states:
            missing.append(state)
    return missing
```

### What This Computes

> All states that exist **but were never guessed**

This list is:

* Order-preserving
* Deterministic
* Independent of UI

---

### Why Not Use Set Difference?

* Lists preserve order
* Order matches original CSV
* Easier mental trace for beginners

Correctness > micro-optimizations here.

---

## `save_missing_to_csv` — Persistence Layer

```python
def save_missing_to_csv(self, filename):
    missing = self.get_missing_states()
    df = pd.DataFrame(missing, columns=["state"])
    df.to_csv(filename, index=False)
```

### Responsibility

* Convert domain data → structured output
* Persist learning gaps
* Enable offline review

---

### Why Pandas for This?

| Reason               | Explanation          |
| -------------------- | -------------------- |
| Clean column naming  | Explicit schema      |
| CSV safety           | No manual formatting |
| Future extensibility | Easy to add columns  |

---

## Output File Structure

`states_to_learn.csv`

```text
state
Alabama
Alaska
Arizona
...
```

This file is **educational feedback**, not game data.

---

## Data Flow Inside `DataManager`

```
CSV file
   ↓
DataFrame
   ↓
all_states list
   ↓
state_positions dict
   ↓
guessed_states list
   ↓
missing_states list
   ↓
CSV export
```

---

## Key Pandas Concepts Used (Precisely)

| Feature       | Usage             |
| ------------- | ----------------- |
| `read_csv`    | Data ingestion    |
| Column access | `data.state`      |
| `iterrows()`  | One-time indexing |
| `DataFrame()` | Export structure  |
| `to_csv()`    | Persistence       |

---

## Design Strengths of This Layer

| Aspect                | Quality  |
| --------------------- | -------- |
| Single responsibility | Strong   |
| Lookup efficiency     | O(1)     |
| Testability           | High     |
| UI independence       | Complete |

---

## What Is *Not* Done Here (By Design)

* No user input
* No rendering
* No looping
* No exit logic

This keeps the system **predictable and maintainable**.

---
