## STEP 3 — GAME ORCHESTRATION & CONTROL FLOW (`main.py`)

> Scope of this step
> Only **game loop**, **decision-making**, **layer coordination**, **exit behavior**, and **final output logic**
> No turtle internals, no pandas internals

This file is the **conductor**, not a worker.

---

## Role of `main.py`

`main.py` does **not**:

* Store data
* Parse CSVs
* Draw graphics

`main.py` **does**:

* Coordinate `DataManager` and `MapManager`
* Control game flow
* Decide *when* things happen
* Enforce stopping conditions

This is textbook **application orchestration**.

---

## Imports — Dependency Wiring

```python
from data_manager import DataManager
from map_manager import MapManager
```

### Meaning

* `main.py` depends on **interfaces**, not implementations
* No direct `pandas` or `turtle` usage here
* This enforces clean layering

---

## SETUP PHASE — One-Time Initialization

```python
data = DataManager("50_states.csv")
```

### What This Achieves

* Loads all states
* Prepares lookup tables
* Initializes progress tracking

At this point:

* No UI
* No game loop
* Only data readiness

---

```python
map_ui = MapManager(
    image="blank_states_img.gif",
    width=725,
    height=491,
    title="U.S. States Game"
)
```

### What This Achieves

* Creates the screen
* Displays the map
* Prepares text writer
* Locks UI lifecycle

At this point:

* No data logic
* No guesses
* Only UI readiness

---

## Game Loop — Core Control Structure

```python
while len(data.guessed_states) < len(data.all_states):
```

### Loop Condition Explained

| Left            | Right                 |
| --------------- | --------------------- |
| Correct guesses | Total possible states |

This guarantees:

* Game ends only when all states are guessed
* Or exits explicitly via `"Exit"`

No infinite loop risk.

---

## Asking for User Input (Delegated UI)

```python
answer = map_ui.ask_state(
    score=len(data.guessed_states),
    total=len(data.all_states)
)
```

### Responsibilities Split

| Component    | Role                             |
| ------------ | -------------------------------- |
| `main.py`    | Decides *when* to ask            |
| `MapManager` | Handles *how* input is collected |

The score display is **dynamic**, reinforcing progress.

---

## Handling Cancel / Empty Input

```python
if answer is None:
    continue
```

Why this matters:

* User may cancel dialog
* Prevents `.title()` crash
* Loop remains stable

This is defensive programming.

---

## Normalizing User Input

```python
answer = answer.title()
```

### Purpose

* Converts `"texas"` → `"Texas"`
* Matches CSV formatting
* Prevents false negatives

Normalization belongs in **control flow**, not data layer.

---

## Exit Command — Explicit Game Termination

```python
if answer == "Exit":
```

This is the **only intentional break path**.

---

### Revealing Missing States

```python
missing = data.get_missing_states()
for state in missing:
    x, y = data.get_position(state)
    map_ui.write_state(state, x, y)
```

What this does:

* Computes learning gaps
* Uses data for coordinates
* Uses UI to render labels

This is **layer cooperation**, not coupling.

---

### Persisting Learning Progress

```python
data.save_missing_to_csv("states_to_learn.csv")
break
```

Why this is powerful:

* Converts gameplay into study material
* Encourages iteration
* Makes the game educational, not disposable

---

## Valid Guess Path

```python
if data.is_valid_state(answer):
```

### Responsibility Boundary

| Question              | Owner         |
| --------------------- | ------------- |
| Is this a real state? | `DataManager` |
| Should we act on it?  | `main.py`     |

---

### Preventing Duplicate Guesses

```python
if answer not in data.guessed_states:
```

This ensures:

* No double scoring
* No overwriting
* Stable UI behavior

---

### Successful Guess Handling

```python
data.add_guess(answer)
x, y = data.get_position(answer)
map_ui.write_state(answer, x, y)
```

Execution order matters:

1. Update data state
2. Fetch coordinates
3. Render UI

This preserves consistency.

---

## Loop Termination (All States Guessed)

When the `while` condition fails:

* All states guessed
* No explicit `break` needed
* Loop exits naturally

This is **clean termination logic**.

---

## UI Shutdown Phase

```python
map_ui.close_on_click()
```

Why this is outside the loop:

* Ensures it runs once
* Allows user to inspect final map
* Prevents premature exit

---

## Full Control Flow (High-Level)

```
Initialize DataManager
Initialize MapManager
↓
while game not complete:
    ask for input
    normalize input
    if Exit:
        reveal missing
        save CSV
        break
    if valid guess:
        record guess
        write on map
↓
wait for click
exit cleanly
```

---

## Design Qualities of This Step

| Quality       | Result                          |
| ------------- | ------------------------------- |
| Readability   | Linear, narrative flow          |
| Separation    | Strong layer boundaries         |
| Robustness    | Handles cancel + duplicates     |
| Extensibility | Easy to add timer, score, hints |

---

## What Makes This Professional-Level

* No global state
* No mixed concerns
* No UI logic in data layer
* No data logic in UI layer
* Single orchestration point

This is exactly how **small games scale into larger applications**.

---
